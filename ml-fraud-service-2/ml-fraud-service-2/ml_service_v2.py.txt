from flask import Flask, request, jsonify
from flask_cors import CORS
import joblib
import numpy as np
import pandas as pd
import logging
import time
from datetime import datetime
import os

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)

# Chemins des modèles
MODEL_PATH = "models/random_forest_fraude_model.pkl"
SCALER_PATH = "models/scaler_fraude.pkl"

# Variables globales pour les modèles
model = None
scaler = None

# Colonnes attendues par le modèle (à adapter selon votre modèle)
FEATURE_COLUMNS = [
    'RC', 'D_rec', 'incendie', 'vol', 'DOMMAGES_AU_VEHICULE',
    'DOMMAGES_ET_COLLISION', 'BRIS_DE_GLACES', 'PTA', 'INDIVIDUELLE_ACCIDENT',
    'CATASTROPHE_NATURELLE', 'EMEUTE_MOUVEMENT_POPULAIRE', 'VOL_RADIO_CASSETTE',
    'Assistanceet_carglass', 'carglass', 'TOTAL_TAXE', 'FRAIS',
    'TOTAL_PRIME_NETTE', 'capitale_inc', 'capitale_vol', 'capitale_DV',
    'VALEUR_CATALOGUE', 'VALEUR_VENALE'
]

def load_models():
    """Charger le modèle et le scaler"""
    global model, scaler
    try:
        if os.path.exists(MODEL_PATH):
            model = joblib.load(MODEL_PATH)
            logger.info("Modèle Random Forest chargé avec succès")
        else:
            logger.error(f"Fichier modèle non trouvé : {MODEL_PATH}")
            return False
            
        if os.path.exists(SCALER_PATH):
            scaler = joblib.load(SCALER_PATH)
            logger.info("Scaler chargé avec succès")
        else:
            logger.warning(f"Fichier scaler non trouvé : {SCALER_PATH}")
            scaler = None
            
    except Exception as e:
        logger.error(f"Erreur lors du chargement des modèles : {str(e)}")
        return False
    return True

def validate_input_data(data):
    """Valider les données d'entrée"""
    if not isinstance(data, dict):
        return False, "Les données doivent être un objet JSON"
    
    if 'contractData' not in data:
        return False, "Le champ 'contractData' est requis"
    
    contract_data = data['contractData']
    
    # Vérifier que toutes les colonnes requises sont présentes
    missing_columns = []
    for col in FEATURE_COLUMNS:
        if col not in contract_data:
            missing_columns.append(col)
    
    if missing_columns:
        return False, f"Colonnes manquantes : {missing_columns}"
    
    # Vérifier que les valeurs sont numériques
    for col in FEATURE_COLUMNS:
        try:
            float(contract_data[col])
        except (ValueError, TypeError):
            return False, f"La valeur de '{col}' doit être numérique"
    
    return True, "Données valides"

@app.route('/health', methods=['GET'])
def health_check():
    """Endpoint de vérification de santé"""
    return jsonify({
        "status": "healthy",
        "model_loaded": model is not None,
        "scaler_loaded": scaler is not None,
        "timestamp": datetime.now().isoformat(),
        "version": "2.0.0",
        "service": "fraud-detection-v2"
    })

@app.route('/predict', methods=['POST'])
def predict():
    """Endpoint principal de prédiction"""
    start_time = time.time()
    
    try:
        # Récupérer les données de la requête
        data = request.get_json()
        
        if not data:
            return jsonify({
                "error": "Aucune donnée JSON fournie",
                "code": "INVALID_INPUT"
            }), 400
        
        # Valider les données d'entrée
        is_valid, validation_message = validate_input_data(data)
        if not is_valid:
            return jsonify({
                "error": validation_message,
                "code": "VALIDATION_ERROR"
            }), 400
        
        # Vérifier que le modèle est chargé
        if model is None:
            return jsonify({
                "error": "Modèle ML non disponible",
                "code": "MODEL_UNAVAILABLE"
            }), 503
        
        # Extraire les caractéristiques dans le bon ordre
        contract_data = data['contractData']
        features = []
        for col in FEATURE_COLUMNS:
            features.append(float(contract_data[col]))
        
        # Convertir en array numpy
        input_array = np.array([features])
        
        # Appliquer le scaler si disponible
        if scaler is not None:
            input_array = scaler.transform(input_array)
            logger.info("Données normalisées avec le scaler")
        
        # Faire la prédiction
        prediction = model.predict(input_array)[0]
        prediction_proba = model.predict_proba(input_array)[0]
        
        # Calculer le score de confiance
        confidence = float(max(prediction_proba))
        
        # Déterminer le niveau de risque
        if confidence >= 0.9:
            risk_level = "VERY_HIGH" if prediction == 1 else "VERY_LOW"
        elif confidence >= 0.7:
            risk_level = "HIGH" if prediction == 1 else "LOW"
        else:
            risk_level = "MEDIUM"
        
        # Calculer le temps de traitement
        processing_time = int((time.time() - start_time) * 1000)
        
        # Construire la réponse
        response = {
            "prediction": {
                "isFraud": bool(prediction),
                "confidence": round(confidence, 4),
                "riskLevel": risk_level,
                "fraudProbability": round(float(prediction_proba[1]), 4)
            },
            "model": {
                "version": "2.0.0",
                "featuresUsed": len(FEATURE_COLUMNS),
                "algorithm": "RandomForest",
                "scalerUsed": scaler is not None
            },
            "metadata": {
                "requestId": data.get('metadata', {}).get('requestId', 'unknown'),
                "processingTime": processing_time,
                "timestamp": datetime.now().isoformat(),
                "service": "fraud-detection-v2"
            }
        }
        
        # Logger la prédiction
        logger.info(f"Prédiction V2 - Fraude: {prediction}, Confiance: {confidence:.4f}")
        
        return jsonify(response)
        
    except Exception as e:
        logger.error(f"Erreur lors de la prédiction : {str(e)}")
        return jsonify({
            "error": "Erreur interne du serveur",
            "code": "INTERNAL_ERROR",
            "details": str(e)
        }), 500

@app.route('/model/info', methods=['GET'])
def model_info():
    """Informations sur le modèle"""
    if model is None:
        return jsonify({"error": "Modèle non chargé"}), 503
    
    return jsonify({
        "model": {
            "type": str(type(model).__name__),
            "features": FEATURE_COLUMNS,
            "featureCount": len(FEATURE_COLUMNS),
            "version": "2.0.0",
            "scalerAvailable": scaler is not None
        },
        "status": "loaded",
        "timestamp": datetime.now().isoformat()
    })

if __name__ == '__main__':
    # Charger les modèles au démarrage
    if not load_models():
        logger.error("Impossible de charger les modèles. Arrêt du service.")
        exit(1)
    
    # Démarrer le serveur Flask sur un port différent
    app.run(host='0.0.0.0', port=5001, debug=False)